import sys
import json

def main():
    try:
        # Read from stdin
        input_str = sys.stdin.read()
        if not input_str or not input_str.strip():
            print("DAILY_SUMMARY Reason=EMPTY_INPUT")
            return

        try:
            d = json.loads(input_str)
        except json.JSONDecodeError:
            print("DAILY_SUMMARY Reason=INVALID_JSON")
            return
        
        # Check error (detail)
        if "detail" in d:
             msg = str(d.get('detail', 'unknown')).replace(" ", "_")
             print(f"DAILY_SUMMARY Reason=API_ERROR detail={msg}")
             return

        # Unwrap "data" if present (FastAPI common wrapper)
        if "data" in d and isinstance(d["data"], dict):
            d = d["data"]
        
        # Unwrap "rows" if present (Common list response wrapper)
        if "rows" in d and isinstance(d["rows"], list) and len(d["rows"]) > 0:
            d = d["rows"][0]



        # Parsing logic (Robust)
        ops = d.get("ops_status")
        if not ops:
            ops = "MISSING_OPS"
            # Debug: Print keys if ops_status is missing
            # But we must output in DAILY_SUMMARY format for grep to work (partial)
            # We'll rely on the default printing but add debug info if possible
            # Actually, let's just use the defaults but maybe add a debug print to stderr?
            # Script captures stdout. usage: ... | python script.py | sed ...
            print(f"DEBUG: Available keys: {list(d.keys())}", file=sys.stderr)

        live = d.get("live_status", {}) or {}
        live_res = f"{live.get('result','MISSING_RESULT')}/{live.get('decision','MISSING_DECISION')}"
        
        bundle = d.get("bundle", {}) or {}
        bundle_stale = str(bundle.get("stale", "missing_stale")).lower()
        
        reco = d.get("reco", {}) or {}
        reco_decision = reco.get("decision", "MISSING_RECO")
        
        order = d.get("order_plan", {}) or {}
        op_decision = order.get("decision", "MISSING_OP")
        
        risks = d.get("top_risks", []) or []
        
        # P81-FIX v2.2: Filter ORDER_PLAN_* risks when order_plan=SKIPPED
        if op_decision == "SKIPPED":
            risks = [r for r in risks if not r.startswith("ORDER_PLAN_")]
        
        # P83-FIX: Strict single risk when bundle_stale (root cause)
        # When stale, ALL other risks are downstream effects - show only root cause
        if bundle_stale == "true":
            risks = ["BUNDLE_STALE_WARN"]
            
        risks_str = str(risks).replace(" ", "")

        # Reason Logic (P83: Priority Reordering for Actionable WHY)
        # Priority: GIT_PULL_FAILED > BUNDLE_STALE_WARN > ORDER_PLAN_* > EMPTY_RECO > OK
        reason = "UNMAPPED_CASE"  # Default fallback - never UNKNOWN
        
        # P87-FIX: SSOT Logic (Re-verified)
        if op_decision == "BLOCKED":
            op_reason = order.get("reason", "")
            op_reason_code = op_reason.split(":")[0].strip() if op_reason else "UNKNOWN"
            
            # P86: SSOT Logic (Stale check)
            if op_reason_code in ("RECO_BUNDLE_STALE", "BUNDLE_STALE"):
                # Usually caught by bundle_stale==true, but if not..
                pass 
            elif op_reason_code and op_reason_code != "BLOCKED":
                if op_reason_code.startswith("ORDER_PLAN_"):
                    pass # reason already set likely
                else:
                    pass
        
        # P87-FIX2: SSOT Priority & Detail Logic (Strict)
        # Priority: Bundle Stale > Order Plan Blocked > Reco Empty > Ops Warning > OK
        
        reason = "UNMAPPED_CASE"
        detail_msg = ""
        
        # 1. Bundle Stale (Root Cause)
        # P88: Detail SSOT Hardening (Direct API Fetch)
        # Goal: Ensure detail comes from SSOT (/api/order_plan/latest) if ORDER_PLAN block
        if reason.startswith("ORDER_PLAN_"):
            try:
                import urllib.request
                with urllib.request.urlopen("http://localhost:8000/api/order_plan/latest", timeout=1) as response:
                    if response.status == 200:
                        op_latest = json.loads(response.read().decode())
                        # Flattened or Rows? API returns CheckResult format usually (rows) or dict?
                        # P87-FIX2 verification used: curl ... | grep reason_detail.
                        # Usually /api/latest APIs return {rows: [...]} OR single dict depending on endpoint.
                        # Let's check get_order_plan_latest implementation or assume standard row wrapper.
                        # safe_read_json returns dict. If generated by `_save_plan`, it is a dict (PLAN schema).
                        # It validates correctly with `rows` usually only if it's a "CheckResult".
                        # `generate_order_plan` saves the PLAN dict directly.
                        # So it is likely a plain dict.
                        # But `api/order_plan/latest` might wrap it?
                        # Let's assume plain dict based on `generate_order_plan.py`.
                        # Fallback: check both.
                        detail_candidate = op_latest.get("reason_detail", "")
                        if not detail_candidate and "rows" in op_latest:
                             detail_candidate = op_latest["rows"][0].get("reason_detail", "")
                        
                        detail_msg = detail_candidate
                        
                        if not detail_msg:
                             detail_msg = "MISSING_DETAIL"
                    else:
                        detail_msg = "DETAIL_SOURCE_UNAVAILABLE (HTTP Error)"
            except Exception as e:
                # API not available (e.g. backend down) or connection error
                detail_msg = "DETAIL_SOURCE_UNAVAILABLE"

        # P87-FIX2: Fallback for other cases or if API fetch logic was skipped (not ORDER_PLAN)
        # (This block handles BUNDLE_STALE, RECO, OPS cases)
        elif not detail_msg:
             # Logic from P87-FIX2 (Bundle, Reco, Ops)
             if "BUNDLE_STALE" in reason:
                  detail_msg = bundle.get("stale_reason", "") or bundle.get("summary", {}).get("stale_reason", "") or "Strategy bundle is stale"
             elif "RECO" in reason:
                  detail_msg = reco.get("reason_detail", "") or "MISSING_DETAIL"
             elif "OPS" in reason:
                  detail_msg = d.get("ops_summary", {}).get("message", "")
             
        # Safe string for log (remove newlines, truncate if too long)
        # P88: Strict Sanitize (1 line, escape quotes, 240 chars)
        detail_safe = str(detail_msg).replace("\n", " ").replace("\r", "").replace('"', "'").strip()[:240]

        # Print Standard Summary to stdout (for daily_summary.latest)
        summary_line = f"DAILY_SUMMARY ops={ops} live={live_res} bundle_stale={bundle_stale} reco={reco_decision} order_plan={op_decision} Reason={reason} risks={risks_str}"
        print(summary_line)

        # P87-FIX: Write Detail Log to File (Side Effect) - Operator Recovery
        try:
             with open("logs/daily_summary.detail.latest", "w", encoding="utf-8") as f:
                  f.write(f'Reason={reason} detail="{detail_safe}"\n')
        except Exception:
             pass # Fail silent on side-effect log gen


    except Exception as e:
        print(f"DAILY_SUMMARY Reason=PARSE_ERROR error={str(e)}")

if __name__ == "__main__":
    main()
